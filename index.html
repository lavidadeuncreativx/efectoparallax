<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kitasenju Real Replica</title>
  <style>
    body, html {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background-color: #000; font-family: monospace;
    }
    #canvas-container {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1;
    }
    /* Interfaz de datos (UI) */
    #ui-overlay {
      position: absolute; top: 20px; left: 20px; z-index: 10;
      color: #00ff00; /* Color verde hacker */
      pointer-events: none;
      text-shadow: 0 0 5px #00ff00;
    }
    .data-row { margin-bottom: 5px; font-size: 14px; }
    .data-val { font-weight: bold; }

    /* Botón de Inicio */
    #start-btn {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px; background: white; border: none;
      font-family: sans-serif; font-size: 16px; cursor: pointer;
      z-index: 100; border-radius: 4px;
    }
  </style>
</head>
<body>

  <div id="canvas-container"></div>

  <div id="ui-overlay">
    <div class="data-row">TILT (GAMMA): <span id="val-gamma" class="data-val">0.00</span>°</div>
    <div class="data-row">EFFECT STR: <span id="val-effect" class="data-val">0.00</span></div>
  </div>

  <button id="start-btn">INICIAR SISTEMA</button>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

    let camera, scene, renderer, composer, rgbPass;
    let planes = [];
    let currentTilt = 0;
    let targetTilt = 0;

    // Elementos UI
    const valGamma = document.getElementById('val-gamma');
    const valEffect = document.getElementById('val-effect');
    const startBtn = document.getElementById('start-btn');

    init();

    function init() {
      // 1. Configuración básica de Three.js
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // 2. Cargar texturas (TUS IMÁGENES AQUÍ)
      const loader = new THREE.TextureLoader();
      // Asegúrate de que img1, img2, img3 estén en tu GitHub
      const texture1 = loader.load('img1.png'); 
      const texture2 = loader.load('img2.png');
      const texture3 = loader.load('img3.png');

      // 3. Crear los planos (las "hojas" 3D)
      // Usamos Blending Aditivo para que los colores se sumen como luz
      const materialBasic = { transparent: true, blending: THREE.AdditiveBlending, depthWrite: false };
      
      const planeGeometry = new THREE.PlaneGeometry(4, 4); // Ajusta el tamaño si es necesario

      const mat1 = new THREE.MeshBasicMaterial({ map: texture1, ...materialBasic, opacity: 0 });
      const mat2 = new THREE.MeshBasicMaterial({ map: texture2, ...materialBasic, opacity: 1 });
      const mat3 = new THREE.MeshBasicMaterial({ map: texture3, ...materialBasic, opacity: 0 });

      planes = [
        new THREE.Mesh(planeGeometry, mat1),
        new THREE.Mesh(planeGeometry, mat2),
        new THREE.Mesh(planeGeometry, mat3)
      ];

      // Separamos un poco los planos en profundidad (Z)
      planes[0].position.z = -0.2;
      planes[1].position.z = 0;
      planes[2].position.z = 0.2;

      scene.add(...planes);

      // 4. POST-PROCESAMIENTO (EL EFECTO KITASENJU)
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      // Añadimos el shader de RGB Split
      rgbPass = new ShaderPass(RGBShiftShader);
      rgbPass.uniforms['amount'].value = 0.0; // Empieza sin efecto
      rgbPass.uniforms['angle'].value = 0.0;
      composer.addPass(rgbPass);

      window.addEventListener('resize', onWindowResize);
      animate();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    // Bucle de animación (corre 60 veces por segundo)
    function animate() {
      requestAnimationFrame(animate);

      // Suavizado del movimiento (Lerp)
      currentTilt += (targetTilt - currentTilt) * 0.1;

      // --- LÓGICA CENTRAL ---
      
      // 1. Actualizar UI con datos
      valGamma.innerText = currentTilt.toFixed(2);
      
      // 2. Calcular intensidad del efecto RGB basado en el tilt
      // Cuanto más te alejas del centro, más se separan los colores
      const effectStrength = Math.abs(currentTilt) * 0.0005;
      rgbPass.uniforms['amount'].value = effectStrength;
      valEffect.innerText = (effectStrength * 100).toFixed(2); // Mostrar dato en UI

      // 3. Mezclar opacidades de las imágenes (Lógica similar a la anterior)
      const range = 30;
      planes[0].material.opacity = Math.max(0, 1 - Math.abs(currentTilt - (-range)) / range); // Izquierda
      planes[1].material.opacity = Math.max(0, 1 - Math.abs(currentTilt - 0) / range);       // Centro
      planes[2].material.opacity = Math.max(0, 1 - Math.abs(currentTilt - range) / range);    // Derecha

      // 4. Renderizar con el composer (que incluye el efecto)
      composer.render();
    }

    // --- MANEJO DEL GIROSCOPIO ---
    function handleOrientation(event) {
      // Limitamos el tilt entre -45 y 45 grados
      targetTilt = Math.max(-45, Math.min(45, event.gamma));
    }

    startBtn.addEventListener('click', () => {
      startBtn.style.display = 'none';
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(resp => {
            if (resp === 'granted') window.addEventListener('deviceorientation', handleOrientation);
          });
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }
    });
  </script>
</body>
</html>
